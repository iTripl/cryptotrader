CryptoTrader pseudocode and explanation

PSEUDOCODE (simple)
1) start program
   - read config.ini
   - apply CLI overrides (mode, dry_run, debug, interactive)
   - build components (exchange, strategy manager, risk, execution, state)
2) run trading loop
   - initialize portfolio with starting equity
   - start strategy processes (or local mode for backtest)
   - start order tracker if live/forward
   - for each candle from data stream:
       - if killswitch triggered: cancel open orders, stop loop
       - if backtest: apply stop loss / take profit
       - update features and latest prices
       - refresh portfolio metrics (drawdown, exposure, expectancy)
       - get signals from strategies
       - for each signal:
           - risk_manager.approve(signal, portfolio)
           - if rejected: maybe trigger killswitch, skip
           - size order (respect max size, reject if below min constraints)
           - execution_engine.execute(signal, size)
           - save order; track fills or apply accounting
       - process fills (live/forward)
   - if backtest: close remaining positions and write report
   - close state repository

HOW IT WORKS (newbie friendly)
- This project is a trading pipeline. It connects data, strategies, risk checks, and execution.
- A "candle" is one time slice of price data (open, high, low, close).
- A "signal" is a strategy's suggestion like BUY, SELL, or FLAT.
- The system repeats this loop: new candle -> strategy signals -> risk check -> order -> update portfolio.
- Risk rules are enforced before orders are sent. If risk limits are hit, trading stops.
- In backtest mode, orders are simulated and trades update equity immediately.
- In live/forward mode, orders are sent to the exchange and fills update the portfolio.

CHATBOT FRIENDLY NOTES
- Think of it as a state machine:
  Candle -> Signal -> RiskDecision -> Order -> Fill -> PortfolioUpdate
- The main entry is main.py, which builds the app and runs TradingApplication.run().
- StrategyManager creates signals; RiskManager blocks or sizes trades.
- ExecutionEngine turns signals into orders (real or simulated).
- StateRepository stores orders, fills, and trades for later analysis.
